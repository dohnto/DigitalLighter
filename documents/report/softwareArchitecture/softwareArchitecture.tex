In this chapter, product architecture is described using 4 + 1 architectural view model \footnote{Ph. Kruchten, "The 4+1 View Model of Architecture," IEEE Software, vol. 12 (6), pp. 45-50, 1995.}. It is based on the multiple concurrent views and therefore better explanation of architecture can be provided.
Only high level design will be presented in this chapter and in each sprint, specific, detailed architecture will be described.
The design is made with emphasis on generality, therefore it is possible, that in particular sprints in the architecture section it will be adapted to specific situation.

Since some design patterns were used, the purpose of using specific pattern and its advantages will be discussed in the end of this chapter.

\section{Logical view}
The description of the functional requirements of the architecture. The client and the server are decomposed into a set of key abstractions, taken(mostly) from the problem domain, in the form of objects or object classes.

\section{Development view}

%% IMPORTANT: just copied from ibm.com, need to rewrite!
In component-based development (CBD), component diagrams offer architects a natural format
to begin modeling a solution. Component diagrams allow an architect to verify that a system's
required functionality is being implemented by components, thus ensuring that the eventual system
will be acceptable.
In addition, component diagrams are useful communication tools for various groups. The diagrams
can be presented to key project stakeholders and implementation staff. While component diagrams
are generally geared towards a system's implementation staff, component diagrams can generally
put stakeholders at ease because the diagram presents an early understanding of the overall
system that is being built.
%% IMPORTANT: just copied from ibm.com, need to rewrite!

\section{Process view}
The process view shows concurrency and distribution of a system and system's processes.
It can also show communication between these units.
Process view can be described by activity diagrams.

You can see activity diagrams in Figures \ref{fig:activity_diagram_server} and \ref{fig:activity_diagram_client}. Note, that client application is sending signal action \emph{connect to server}, which is connected to server's event action \emph{new client connected}. 
 All clients connections are stored in datastore \emph{client list} and particular actions require all client connections to be able to send any information to clients.

\begin{figure}[H]
	\centering
		\includegraphics[width=16.2cm]{softwareArchitecture/activity_server.pdf}
	\caption{Activity diagram of server application}
	\label{fig:activity_diagram_server}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[width=16.2cm]{softwareArchitecture/activity_client.pdf}
	\caption{Activity diagram of client application}
	\label{fig:activity_diagram_client}
\end{figure}


\section{Physical view}
The physical view \cite{Kruchten:1995:VMA:624610.625529} describes a mapping of software onto hardware. 
It takes into account non-functional requirements of the system and it can be described by deployment diagrams.

Deployment diagram depicting physical view can be seen in Figure \ref{fig:architecture_deployment_diagram}.
According to requirement \refreq{N1}, there are two executable files deployed; one deployed to client device and second to server device.
There is also need for NTP\footnote{http://ntp.org/} server, which will maintain all connected devices synchronized.
To generalize the architecture design, the \emph{camera} device is treated as a separate device, which will only send its output to server device.

\begin{figure}[H]
	\centering
		\includegraphics[width=15cm]{softwareArchitecture/deployment-diagram.pdf}
	\caption{Deployment diagram}
	\label{fig:architecture_deployment_diagram}
\end{figure}

\section{Scenarios}
Use case diagrams can be considered as scenarios, therefore introduced diagram \ref{img:usecase} in Requirements chapter can be considered as a scenario.

\section{Used design patterns}
\subsection{Strategy}
\subsection{Model-View-Controller}
\subsection{Observer}